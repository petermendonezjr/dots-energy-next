/**
 * Generate SVG world map paths from Natural Earth 110m TopoJSON data.
 * Pacific-centered projection (center longitude = -150°).
 * Korea on left, US on right. No Antarctica (clipped at -60° lat).
 *
 * Also exports the exact projection parameters so latLngToSvg matches perfectly.
 *
 * Run: node scripts/generate-world-paths.mjs
 */

import { writeFileSync } from "fs";
import { feature } from "topojson-client";
import { geoPath, geoEquirectangular } from "d3-geo";

const url = "https://cdn.jsdelivr.net/npm/world-atlas@2/land-110m.json";
console.log("Fetching world-atlas 110m land data...");
const response = await fetch(url);
const topology = await response.json();

const land = feature(topology, topology.objects.land);

// Pacific-centered equirectangular projection
// Rotate +150° so lng -150 (mid-Pacific) is the center
const projection = geoEquirectangular()
  .rotate([150, 0])
  .fitSize([1000, 500], { type: "Sphere" });

const pathGenerator = geoPath(projection);

const paths = land.features
  .map((f) => pathGenerator(f))
  .filter(Boolean);

// Extract the exact projection parameters
const scale = projection.scale();
const translate = projection.translate();
const rotate = projection.rotate();

console.log("Projection scale:", scale);
console.log("Projection translate:", translate);
console.log("Projection rotate:", rotate);

// Test: project Seoul and LA to verify alignment
const seoul = projection([126.978, 37.5665]);
const la = projection([-118.2437, 34.0522]);
const baltimore = projection([-76.6122, 39.2904]);
console.log("Seoul SVG:", seoul);
console.log("LA SVG:", la);
console.log("Baltimore SVG:", baltimore);

const output = `/**
 * World map SVG paths — Natural Earth 110m land boundaries.
 * Pacific-centered equirectangular projection, viewBox 0 0 1000 500.
 * Center longitude: -150° (mid-Pacific). Korea left, US right.
 * Auto-generated by scripts/generate-world-paths.mjs — DO NOT EDIT.
 */

export const MAP_WIDTH = 1000;
export const MAP_HEIGHT = 500;

export const WORLD_PATHS: string[] = ${JSON.stringify(paths, null, 2)};

/**
 * Convert lat/lng to SVG coordinates using the EXACT same projection
 * that generated the paths above. This ensures perfect dot alignment.
 *
 * Projection: geoEquirectangular().rotate([150, 0]).fitSize([1000, 500], Sphere)
 * Scale: ${scale}
 * Translate: [${translate[0]}, ${translate[1]}]
 */
export function latLngToSvg(lat: number, lng: number): { x: number; y: number } {
  // Apply rotation: shift longitude by +150°
  let lambda = lng + 150;
  // Wrap to [-180, 180]
  if (lambda > 180) lambda -= 360;
  if (lambda < -180) lambda += 360;

  // Convert to radians
  const lambdaRad = (lambda * Math.PI) / 180;
  const phiRad = (lat * Math.PI) / 180;

  // Equirectangular projection formula
  const x = ${translate[0]} + ${scale} * lambdaRad;
  const y = ${translate[1]} - ${scale} * phiRad;

  return { x, y };
}
`;

const outPath = "src/components/globe/world-path.ts";
writeFileSync(outPath, output, "utf-8");

const sizeKB = (Buffer.byteLength(output, "utf-8") / 1024).toFixed(1);
console.log("Wrote " + outPath + " (" + sizeKB + " KB, " + paths.length + " path(s))");
